// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEventByID = `-- name: GetEventByID :one
SELECT id, subject, tenant_id, resource_id, event_type, payload, status, retry_count, next_attempt_at, last_error, created_at, updated_at
FROM billing_events
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEventByID(ctx context.Context, id int64) (BillingEvents, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i BillingEvents
	err := row.Scan(
		&i.ID,
		&i.Subject,
		&i.TenantID,
		&i.ResourceID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.NextAttemptAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEventsByFilters = `-- name: ListEventsByFilters :many
SELECT id, subject, tenant_id, resource_id, event_type, payload, status, retry_count, next_attempt_at, last_error, created_at, updated_at
FROM billing_events
WHERE (tenant_id = $1)
  AND (event_type = $2)
  AND (created_at >= $3)
  AND (created_at <= $4)
ORDER BY created_at ASC
`

type ListEventsByFiltersParams struct {
	TenantID    int64              `json:"tenant_id"`
	EventType   pgtype.Text        `json:"event_type"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

func (q *Queries) ListEventsByFilters(ctx context.Context, arg ListEventsByFiltersParams) ([]BillingEvents, error) {
	rows, err := q.db.Query(ctx, listEventsByFilters,
		arg.TenantID,
		arg.EventType,
		arg.CreatedAt,
		arg.CreatedAt_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingEvents
	for rows.Next() {
		var i BillingEvents
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.TenantID,
			&i.ResourceID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.NextAttemptAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByType = `-- name: ListEventsByType :many
SELECT id, subject, tenant_id, resource_id, event_type, payload, status, retry_count, next_attempt_at, last_error, created_at, updated_at
FROM billing_events
WHERE event_type = $1
ORDER BY created_at ASC
`

func (q *Queries) ListEventsByType(ctx context.Context, eventType pgtype.Text) ([]BillingEvents, error) {
	rows, err := q.db.Query(ctx, listEventsByType, eventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingEvents
	for rows.Next() {
		var i BillingEvents
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.TenantID,
			&i.ResourceID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.NextAttemptAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsForTenant = `-- name: ListEventsForTenant :many
SELECT id, subject, tenant_id, resource_id, event_type, payload, status, retry_count, next_attempt_at, last_error, created_at, updated_at
FROM billing_events
WHERE tenant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListEventsForTenant(ctx context.Context, tenantID int64) ([]BillingEvents, error) {
	rows, err := q.db.Query(ctx, listEventsForTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingEvents
	for rows.Next() {
		var i BillingEvents
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.TenantID,
			&i.ResourceID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.NextAttemptAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
