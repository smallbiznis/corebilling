// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createSubscription = `-- name: CreateSubscription :exec
INSERT INTO subscriptions (
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6,
    $7, $8, $9,
    $10, $11,
    $12, $13,
    $14, now(), now()
)
`

type CreateSubscriptionParams struct {
	ID                 string
	TenantID           string
	CustomerID         string
	PriceID            string
	Status             int16
	AutoRenew          bool
	StartAt            time.Time
	CurrentPeriodStart time.Time
	CurrentPeriodEnd   time.Time
	TrialStartAt       sql.NullTime
	TrialEndAt         sql.NullTime
	CancelAt           sql.NullTime
	CanceledAt         sql.NullTime
	Metadata           pqtype.NullRawMessage
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, createSubscription,
		arg.ID,
		arg.TenantID,
		arg.CustomerID,
		arg.PriceID,
		arg.Status,
		arg.AutoRenew,
		arg.StartAt,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.TrialStartAt,
		arg.TrialEndAt,
		arg.CancelAt,
		arg.CanceledAt,
		arg.Metadata,
	)
	return err
}

const getSubscription = `-- name: GetSubscription :one
SELECT
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscription(ctx context.Context, id string) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CustomerID,
		&i.PriceID,
		&i.Status,
		&i.AutoRenew,
		&i.StartAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialStartAt,
		&i.TrialEndAt,
		&i.CancelAt,
		&i.CanceledAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSubscriptionsByTenant = `-- name: ListSubscriptionsByTenant :many
SELECT
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
FROM subscriptions
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByTenant(ctx context.Context, tenantID string) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CustomerID,
			&i.PriceID,
			&i.Status,
			&i.AutoRenew,
			&i.StartAt,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.TrialStartAt,
			&i.TrialEndAt,
			&i.CancelAt,
			&i.CanceledAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
