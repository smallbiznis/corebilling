// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :exec
INSERT INTO subscriptions (
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6,
    $7, $8, $9,
    $10, $11,
    $12, $13,
    $14, now(), now()
)
`

type CreateSubscriptionParams struct {
	ID                 int64              `json:"id"`
	TenantID           int64              `json:"tenant_id"`
	CustomerID         int64              `json:"customer_id"`
	PriceID            int64              `json:"price_id"`
	Status             int16              `json:"status"`
	AutoRenew          bool               `json:"auto_renew"`
	StartAt            pgtype.Timestamptz `json:"start_at"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	TrialStartAt       pgtype.Timestamptz `json:"trial_start_at"`
	TrialEndAt         pgtype.Timestamptz `json:"trial_end_at"`
	CancelAt           pgtype.Timestamptz `json:"cancel_at"`
	CanceledAt         pgtype.Timestamptz `json:"canceled_at"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, createSubscription,
		arg.ID,
		arg.TenantID,
		arg.CustomerID,
		arg.PriceID,
		arg.Status,
		arg.AutoRenew,
		arg.StartAt,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.TrialStartAt,
		arg.TrialEndAt,
		arg.CancelAt,
		arg.CanceledAt,
		arg.Metadata,
	)
	return err
}

const getSubscription = `-- name: GetSubscription :one
SELECT
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscription(ctx context.Context, id int64) (Subscriptions, error) {
	row := q.db.QueryRow(ctx, getSubscription, id)
	var i Subscriptions
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CustomerID,
		&i.PriceID,
		&i.Status,
		&i.AutoRenew,
		&i.StartAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialStartAt,
		&i.TrialEndAt,
		&i.CancelAt,
		&i.CanceledAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSubscriptionsByTenant = `-- name: ListSubscriptionsByTenant :many
SELECT
    id, tenant_id, customer_id, price_id,
    status, auto_renew,
    start_at, current_period_start, current_period_end,
    trial_start_at, trial_end_at,
    cancel_at, canceled_at,
    metadata, created_at, updated_at
FROM subscriptions
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByTenant(ctx context.Context, tenantID int64) ([]Subscriptions, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscriptions
	for rows.Next() {
		var i Subscriptions
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CustomerID,
			&i.PriceID,
			&i.Status,
			&i.AutoRenew,
			&i.StartAt,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.TrialStartAt,
			&i.TrialEndAt,
			&i.CancelAt,
			&i.CanceledAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
